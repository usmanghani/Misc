<html><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><style>.highlight{background:yellow;}</style><body><font face=Arial size=5>Methods to prevent SQL Injection Input Validation Static query statement Least Privilege Code Verification <span class="highlight">Web</span> Application Gateway SQL Driver Proxy MISC Methods Development Phase QA Phase Production Phase Methods to prevent SQL Injection Input Validation Static query statement Least Privilege Code Verification <span class="highlight">Web</span> Application Gateway SQL Driver Proxy MISC Methods Development Phase QA Phase Production Phase Methods to prevent SQL Injection Input Validation Static query statement Least Privilege Code Verification <span class="highlight">Web</span> Application Gateway SQL Driver Proxy MISC Methods Development Phase QA Phase Production Phase Methods to prevent SQL Injection Input Validation Static query statement Least Privilege Code Verification <span class="highlight">Web</span> Application Gateway SQL Driver Proxy MISC Methods Development Phase QA Phase Production Phase Methods to prevent SQL Injection Input Validation Static query statement Least Privilege Code Verification <span class="highlight">Web</span> Application Gateway SQL Driver Proxy MISC Methods Development Phase QA Phase Production Phase Methods to prevent SQL Injection Input Validation Static query statement Least Privilege Code Verification <span class="highlight">Web</span> Application Gateway SQL Driver Proxy MISC Methods Development Phase QA Phase Production Phase Not to forget the Checklist  Guidelines Rule 1: Do not underestimate the power of the dark side   Rule 2: Use POST requests when actions have side effects  Rule 3: In a server-side context, there’s no such thing as client-side security  Guidelines Rule 4: Never use the Referrer header for authentication or authorization  Rule 5: Always generate a new session ID once the user logs in   Rule 6: Never pass detailed error messages to the client   Guidelines Rule 7: Identify every possible meta character to a subsystem  Rule 8: Always handle meta characters when passing data to subsystems   Rule 9: When possible, pass data separate from control information   Guidelines  Rule 10: Watch out for Multi-level Interpretation   Rule 11: Strive for ‘‘Defense in Depth’’   Rule 12: Don’t blindly trust the API documentation Guidelines Rule 13: Identify all sources of input to the application  Rule 14: Pay attention to the invisible security barrier: validate all input, always   Rule 15: When filtering, use white listing rather than blacklisting Guidelines Rule 16: Do not massage invalid input to make it valid   Rule 17: Create application-level logs   Rule 18: Never use client-side scripts for security Guidelines Rule 19: When possible, use data indirection for server-generated input   Rule 20: Pass as little internal state information as possible to the client  Rule 21: Do not assume that requests will come in a certain order Guidelines Rule 22: Filter all data before including them in a <span class="highlight">web</span> page, no matter the origin   Rule 23: Stick to existing cryptographic algorithms, do not create your own   Rule 24: Never store clear-text passwords Guidelines  Rule 25: Never use GET for secret data, including session IDs  Rule 26: Assume that server-side code is available to attackers   Rule 27: Security is not a product; it’s a process          Stakeholders 	     Rauf		Usman		Adil		  05030012      07030048		    07030017       The important thing is not to stop questioning –Albert Einstein    “And the wisdom is not to try to answer every question” * <span class="highlight">Web</span>-based applications constitute the worst threat of SQL injection. In our Pen Tests, over 60% of our clients continue to be vulnerable to SQL Injection. The main problem with SQL Injection is that the vulnerability is originated when the <span class="highlight">web</span> application is coded. Most programmers are still not aware of the problem. Tutorials and demo "templates" on the Internet and even some that have been shipped with commercial databases promote building queries by concatenating strings, which is the main source for SQL Injection vulnerabilities.  Additionally, a lot of the proposed solutions on the <span class="highlight">web</span> continue to be flawed.  * Almost all SQL databases and programming languages are potentially vulnerable. It is an input validation problem that has to be considered and programmed by the <span class="highlight">web</span> application developer. * A common way of validating users in an application is to by checking if the user and password combination exists in the users table. The following query will bring back one record if there is one row where the login = 'victor' and the password = '123': SELECT * FROM users WHERE login = 'victor' AND password = '123' To code this, a common practice among developers is to concatenate a string with the SQL command and then execute it to see if it returns something different to null. An Active Server Page code where the SQL statement gets concatenated might look like: var sql = "SELECT * FROM users WHERE login = '" + formusr + "' AND password = '" + formpwd + "'";   * SQL Injection occurs when an attacker is able to insert a series of SQL statements into a 'query' by manipulating data input. If an attacker inserts: ' or 1=1 --  into the formusr field he will change the normal execution of the query. By inserting a single quote the username string is closed and the final concatenated string would end up interpreting or 1=1 as part of the command. The -- (double dash) is used to comment everything after the or 1=1 and avoid a wrong syntax error. This could also have been achieved by inserting the following command: ' or '1'='1 By injecting any of the two commands discussed, an attacker would get logged in as the first user in the table. This happens because the WHERE clause ends up validating that the username = ' ' (nothing) OR 1=1 (OR '1'='1' in the second statement) The first conditional is False but the second one is True. By using OR the whole condition is True and therefore all rows from table users are returned. All rows is not null therefore the log in condition is met. * The single quote character closes the string field and therefore allows all of the following text to be interpreted as SQL commands.  To prevent this, a lot of the SQL Injection quick solutions found on the Internet suggest escaping the single quote with a double quote (that is the standard way of escaping single quotes in SQL99).  This is only a half remedy though because there are always numeric fields or dates within forms or parameters that will remain vulnerable. * With a similar syntax a numeric login would not use single quotes because in SQL you only need quotes for strings. This PHP / MySQL code example concatenates a query that uses no single quotes as part of the syntaxis. * Injecting into a numeric field is very similar. The main difference with string injection is that in numeric injection the first number is taken as the complete parameter (no need to close it with a single quote) and all the text after that number will be considered as part of the command.  In this case the # (number sign) is used instead of the -- (double dash) because we are injecting into a MySQL database. * Symbol Usage in SQL99 complaint DBs + Addition operator; also concatenation operator; when used in an URL it becomes a white space) || Concatenation operator in Oracle and Postgres - Subtraction operator; also a range indicator in CHECK constraints = Equality operator <> != Inequality operators >< Greater-than and Less-than operators ( ) Expression or hierarchy delimiter % Wildcard attribute indicator , List item separator @, @@ Local and Global variable indicators . Identifier qualifier separator ‘’ “” Character string indicators “” Quoted identifier indicators -- Single-line comment delimiter # Single-line comment delimiter in MySQL or date delimiter in MS Access /*…*/ Begin and End multiline comment delimiter <span class="highlight">Web</span> Application Security Acknowledgement Most of the stuff in this presentation comes from owasp.org <span class="highlight">Web</span> Application Security  What Do We Mean By Security? Security is fundamentally about protecting assets Security is a path, not a destination Security is identifying potential threats and associated degree of risk Security is about risk management Security is implementing effective countermeasures The Foundations of Security Authentication  Authorization  Auditing  Confidentiality  Integrity  Availability  Who are you?  What can you do?  Non-repudiation  Access control lists (ACLs)  Guarantee that data is protected  Remain available for legitimate users  How You Build a Secure <span class="highlight">Web</span> Application? Can you build a secure <span class="highlight">Web</span> application? Not until you know your threats Threat modeling Design Phase Analyze your application’s architecture  Identify potentially vulnerable areas Applying proven security principles Follow secure coding techniques    Anatomy of attack Secure Your Network, Host, and Application Application Threats and Countermeasures Input Validation Buffer overflow; cross-site scripting; SQL injection; canonicalization Authentication Network eavesdropping; brute force attacks; dictionary attacks; cookie replay; credential theft Authorization Elevation of privilege; disclosure of confidential data; data tampering; luring attacks Configuration management Lack of accountability, over-privileged process and service accounts Session management Session hijacking; session replay; man in the middle                                                                           continued… Application Threats and Countermeasures Parameter manipulation Query string manipulation; form field manipulation; cookie manipulation; HTTP header manipulation Exception management Information disclosure; denial of service Auditing and logging User denies performing an operation; attacker exploits an application without trace; attacker covers his or her tracks Sensitive data Access sensitive data in storage; network eavesdropping; data tampering Cryptography Poor key generation or key management; weak or custom encryption                                                                            Input Validation When developer makes unfounded assumptions about the type, length, format, or range of input data . The following can happen:   Buffer overflows  Cross-site scripting  SQL injection  Canonicalization  Buffer Overflow Denial of service  Causes process to crash  Code injection Alters the program behavior by executing an attacker’s injected code Example: void SomeFunction( char *pszInput ) { char szBuffer[10]; // Input is copied straight into the buffer when no type checking is performed strcpy(szBuffer, pszInput); . . . } Cross Site Scripting Cause arbitrary code to run in a user’s browser The attack targets your application’s users Example Embed your code inside a harmless looking link in an email or website.  www.yourwebapplication.com/logon.aspx?username=<script>alert('hacker code')</script> Canonicalization What is it? Different forms of input that resolve to the same standard name  It can occur when your application  makes security decisions based on the name of a resource [Files, paths, and URLs are resource] Example c:\temp\somefile.dat somefile.dat c:\temp\subdir\..\somefile.dat c:\ temp\ somefile.dat ..\somefile.dat c%3A%5Ctemp%5Csubdir%5C%2E%2E%5Csomefile.dat     SQL injection Exploits input vulnerabilities It can occur when your application uses stored procedures that are passed strings that contain unfiltered user input.   uses input to construct dynamic SQL Example SqlDataAdapter myCommand = new SqlDataAdapter( "SELECT * FROM Users WHERE UserName ='" + txtuid.Text + "'", conn);   How common is it? It is probably the most common Website vulnerability today! It is a flaw in "<span class="highlight">web</span> application" development, it is not a DB or <span class="highlight">web</span> server problem Most programmers are still not aware of this problem A lot of the tutorials & demo “templates” are vulnerable Even worse, a lot of solutions posted on the Internet are not good enough In penetration tests over 60% of the websites turn out to be vulnerable to SQL Injection Vulnerable Applications Almost all SQL databases and programming languages are  potentially vulnerable MS SQL Server, Oracle, MySQL, Postgres, DB2, MS Access, Sybase, Informix, etc Accessed through applications developed using: Perl and CGI scripts that access databases  ASP, JSP, PHP XML, XSL and XSQL  Javascript  VB, MFC, and other ODBC-based tools and APIs  DB specific <span class="highlight">Web</span>-based applications and API’s  Reports and DB Applications  3 and 4GL-based languages (C, OCI, Pro*C, and COBOL) many more How does SQL Injection work? Common vulnerable login query  SELECT * FROM users  WHERE login = 'victor' AND password = '123' (If it returns something then login!) ASP/MS SQL Server login syntax var sql = "SELECT * FROM users WHERE login = '" + formusr +  "' AND password = '" + formpwd + "'";  Injecting through Strings formusr = ' or 1=1 – –  formpwd = anything  Final query would look like this: SELECT * FROM users WHERE username = ' ' or 1=1  – – AND password = 'anything' The power of ' It closes the string parameter Everything after is considered part of the SQL command Misleading Internet suggestions include: Escape it! : replace ' with ' ' String fields are very common but there are other types of fields: Numeric Dates If it were numeric? SELECT * FROM clients  WHERE account = 12345678 AND pin = 1111  PHP/MySQL login syntax $sql = "SELECT * FROM clients WHERE " .  "account = $formacct  AND " .  "pin = $formpin";  Injecting Numeric Fields $formacct = 1 or 1=1 #  $formpin = 1111  Final query would look like this: SELECT * FROM clients WHERE account = 1 or 1=1  # AND pin = 1111 SQL Injection Characters ' or "	character String Indicators -- or #  	single-line comment /*…*/  	multiple-line comment +		addition, concatenate (or space in url) ||		(double pipe) concatenate %		wildcard attribute indicator ?Param1=foo&Param2=bar    URL Parameters PRINT 	useful as non transactional command @variable	local variable @@variable	global variable waitfor delay '0:0:10'	  time delay Countermeasures Methods to prevent SQL Injection Input Validation Static query statement Least Privilege Code Verification <span class="highlight">Web</span> Application Gateway SQL Driver Proxy MISC methods Development Phase QA Phase Production Phase Methods to prevent SQL Injection Input Validation Static query statement Least Privilege Code Verification <span class="highlight">Web</span> Application Gateway SQL Driver Proxy MISC methods Development Phase QA Phase Production Phase Assume all input is malicious  OR  		    Find another job!! Centralize your approach. Do not rely on client-side validation Attacker can bypass client-side security Be careful with canonicalization issues Try to avoid designing applications that accept input file names from the user Let the application determine the file name for the user.   Constrain, reject, and sanitize your input. Methods to prevent SQL Injection Input Validation Static query statement Least Privilege Code Verification <span class="highlight">Web</span> Application Gateway SQL Driver Proxy MISC methods Development Phase QA Phase Production Phase * <span class="highlight">Web</span>-based applications constitute the worst threat of SQL injection. In our Pen Tests, over 60% of our clients continue to be vulnerable to SQL Injection. The main problem with SQL Injection is that the vulnerability is originated when the <span class="highlight">web</span> application is coded. Most programmers are still not aware of the problem. Tutorials and demo "templates" on the Internet and even some that have been shipped with commercial databases promote building queries by concatenating strings, which is the main source for SQL Injection vulnerabilities.  Additionally, a lot of the proposed solutions on the <span class="highlight">web</span> continue to be flawed.  * Almost all SQL databases and programming languages are potentially vulnerable. It is an input validation problem that has to be considered and programmed by the <span class="highlight">web</span> application developer. * A common way of validating users in an application is to by checking if the user and password combination exists in the users table. The following query will bring back one record if there is one row where the login = 'victor' and the password = '123': SELECT * FROM users WHERE login = 'victor' AND password = '123' To code this, a common practice among developers is to concatenate a string with the SQL command and then execute it to see if it returns something different to null. An Active Server Page code where the SQL statement gets concatenated might look like: var sql = "SELECT * FROM users WHERE login = '" + formusr + "' AND password = '" + formpwd + "'";   * SQL Injection occurs when an attacker is able to insert a series of SQL statements into a 'query' by manipulating data input. If an attacker inserts: ' or 1=1 --  into the formusr field he will change the normal execution of the query. By inserting a single quote the username string is closed and the final concatenated string would end up interpreting or 1=1 as part of the command. The -- (double dash) is used to comment everything after the or 1=1 and avoid a wrong syntax error. This could also have been achieved by inserting the following command: ' or '1'='1 By injecting any of the two commands discussed, an attacker would get logged in as the first user in the table. This happens because the WHERE clause ends up validating that the username = ' ' (nothing) OR 1=1 (OR '1'='1' in the second statement) The first conditional is False but the second one is True. By using OR the whole condition is True and therefore all rows from table users are returned. All rows is not null therefore the log in condition is met. * The single quote character closes the string field and therefore allows all of the following text to be interpreted as SQL commands.  To prevent this, a lot of the SQL Injection quick solutions found on the Internet suggest escaping the single quote with a double quote (that is the standard way of escaping single quotes in SQL99).  This is only a half remedy though because there are always numeric fields or dates within forms or parameters that will remain vulnerable. * With a similar syntax a numeric login would not use single quotes because in SQL you only need quotes for strings. This PHP / MySQL code example concatenates a query that uses no single quotes as part of the syntaxis. * Injecting into a numeric field is very similar. The main difference with string injection is that in numeric injection the first number is taken as the complete parameter (no need to close it with a single quote) and all the text after that number will be considered as part of the command.  In this case the # (number sign) is used instead of the -- (double dash) because we are injecting into a MySQL database. * Symbol Usage in SQL99 complaint DBs + Addition operator; also concatenation operator; when used in an URL it becomes a white space) || Concatenation operator in Oracle and Postgres - Subtraction operator; also a range indicator in CHECK constraints = Equality operator <> != Inequality operators >< Greater-than and Less-than operators ( ) Expression or hierarchy delimiter % Wildcard attribute indicator , List item separator @, @@ Local and Global variable indicators . Identifier qualifier separator ‘’ “” Character string indicators “” Quoted identifier indicators -- Single-line comment delimiter # Single-line comment delimiter in MySQL or date delimiter in MS Access /*…*/ Begin and End multiline comment delimiter  </font></body></html>